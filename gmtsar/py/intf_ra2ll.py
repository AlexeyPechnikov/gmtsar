#!/usr/bin/env python3
# Alexey Pechnikov, Sep, 2021, https://github.com/mobigroup/gmtsar
# python3 -m pip install install xarray numpy scipy --upgrade
# intf_ra2ll - Transform Interferogram from Radar to Geographic Coordinates
#import pytest

#intf_ll = intf_ra2ll(phasefilts, intf_ra2ll_matrix)
def intf_ra2ll(images, matrix_ra2ll):
    import xarray as xr
    import numpy as np

    def matrix_transform(img, matrix):
        out = np.where(matrix>=0, img.reshape(-1)[matrix], np.nan)
        dims = len(img.shape)
        if dims > 2:
            return np.expand_dims(out,list(np.arange(dims-2)))
        else:
            return out

    imgs_ll = xr.apply_ufunc(
            matrix_transform,
            images,
            matrix_ra2ll,
            input_core_dims=[['y','x'],['lat','lon']],
            output_core_dims=[('lat','lon')],
            dask='parallelized',
            output_dtypes=[images.dtype]
        )
    return imgs_ll

def intf_ra2ll_matrix(in_trans_datafile, in_trans_gridfile, in_intf_ra_grid, out_matrix_gridfile):
    from scipy.spatial import cKDTree
    import xarray as xr
    import numpy as np

    # trans.dat - file generated by llt_grid2rat (r a topo lon lat)"
    trans = np.fromfile(in_trans_datafile, dtype=np.float64).reshape([-1,5])
    lon_min, lon_max = trans[:,3].min(),trans[:,3].max()
    lat_min, lat_max = trans[:,4].min(),trans[:,4].max()

    trans_ra2ll = xr.open_dataarray(in_trans_gridfile)

    intf = xr.open_dataarray(in_intf_ra_grid)

    intf_ys, intf_xs = xr.broadcast(intf.y,intf.x)
    intf_yxs = np.stack([intf_ys.values.reshape(-1),intf_xs.values.reshape(-1)], axis=1)
    trans_yxs = np.stack([trans[:,1],trans[:,0]], axis=1)

    tree = cKDTree(intf_yxs, compact_nodes=False, balanced_tree=False)
    distance_limit = np.max([intf.y.diff('y')[0],intf.x.diff('x')[0]])
    d, inds = tree.query(trans_yxs, k = 1, distance_upper_bound=distance_limit, workers=8)

    # single integer index mask
    intf2trans = np.where(~np.isinf(d), inds, -1)
    # produce the same output array
    intf_ra2ll = xr.zeros_like(trans_ra2ll).rename('intf_ra2ll')
    intf_ra2ll.values = np.where(trans_ra2ll>=0, intf2trans[trans_ra2ll], -1)

    compression = dict(zlib=True, complevel=3, chunksizes=[512,512])
    # magic: add GMT attribute to prevent coordinates shift for 1/2 pixel
    intf_ra2ll.attrs['node_offset'] = np.int32(1)
    intf_ra2ll.to_netcdf(out_matrix_gridfile, encoding={'intf_ra2ll': compression})

def main():
    import sys

    if not len(sys.argv) == 5:
        print (f"Usage: {sys.argv[0]} trans.dat trans_ra2ll.grd phasefilt.grd intf_ra2ll.grd")
        exit(0)

    in_trans_datafile = sys.argv[1]
    in_trans_gridfile = sys.argv[2]
    in_intf_ra_grid = sys.argv[3]
    out_matrix_gridfile = sys.argv[4]
    # calculate
    intf_ra2ll_matrix(in_trans_datafile, in_trans_gridfile, in_intf_ra_grid, out_matrix_gridfile)

if __name__ == "__main__":
    # execute only if run as a script
    main()
